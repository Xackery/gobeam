// Code generated by protoc-gen-go.
// source: beam.proto
// DO NOT EDIT!

/*
Package gobeam is a generated protocol buffer package.

It is generated from these files:
	beam.proto
	grpc.proto

It has these top-level messages:
	Handshake
	HandshakeACK
	Report
	Error
	ProgressUpdate
	HistogramUint1D
	Coordinate
	StreamRequest
*/
package gobeam

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// Handshake MUST be the first message sent from clients to servers.
// After sending it, they should wait for a HandshakeACK, which will
// contain authentication status.
type Handshake struct {
	// Channel ID you want to connect as.
	Channel *uint32 `protobuf:"varint,1,req,name=channel" json:"channel,omitempty"`
	// That channel's stream key
	StreamKey        *string `protobuf:"bytes,2,req,name=streamKey" json:"streamKey,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Handshake) Reset()                    { *m = Handshake{} }
func (m *Handshake) String() string            { return proto.CompactTextString(m) }
func (*Handshake) ProtoMessage()               {}
func (*Handshake) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Handshake) GetChannel() uint32 {
	if m != nil && m.Channel != nil {
		return *m.Channel
	}
	return 0
}

func (m *Handshake) GetStreamKey() string {
	if m != nil && m.StreamKey != nil {
		return *m.StreamKey
	}
	return ""
}

// This is sent from the server to the client in response to a
// Handshake message. It's only send on a successful handshake.
// In other cases, an error will be sent.
type HandshakeACK struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *HandshakeACK) Reset()                    { *m = HandshakeACK{} }
func (m *HandshakeACK) String() string            { return proto.CompactTextString(m) }
func (*HandshakeACK) ProtoMessage()               {}
func (*HandshakeACK) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// The Report is send down to the streamer's computer at the
// reportFrequency, containing information about connected
// clients and their actions.
type Report struct {
	// Time since start of connection in seconds
	Time             *uint32                `protobuf:"varint,1,req,name=time" json:"time,omitempty"`
	Users            *Report_Users          `protobuf:"bytes,2,req,name=users" json:"users,omitempty"`
	Joystick         []*Report_JoystickInfo `protobuf:"bytes,3,rep,name=joystick" json:"joystick,omitempty"`
	Tactile          []*Report_TactileInfo  `protobuf:"bytes,4,rep,name=tactile" json:"tactile,omitempty"`
	Screen           []*Report_ScreenInfo   `protobuf:"bytes,5,rep,name=screen" json:"screen,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *Report) Reset()                    { *m = Report{} }
func (m *Report) String() string            { return proto.CompactTextString(m) }
func (*Report) ProtoMessage()               {}
func (*Report) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Report) GetTime() uint32 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *Report) GetUsers() *Report_Users {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *Report) GetJoystick() []*Report_JoystickInfo {
	if m != nil {
		return m.Joystick
	}
	return nil
}

func (m *Report) GetTactile() []*Report_TactileInfo {
	if m != nil {
		return m.Tactile
	}
	return nil
}

func (m *Report) GetScreen() []*Report_ScreenInfo {
	if m != nil {
		return m.Screen
	}
	return nil
}

// Contains information about the users connected to the stream.
type Report_Users struct {
	// Total number of users connected to the stream.
	Connected *uint32 `protobuf:"varint,1,req,name=connected" json:"connected,omitempty"`
	// Number of users who gave any kind of input in the last 30 seconds.
	Quorum *uint32 `protobuf:"varint,2,req,name=quorum" json:"quorum,omitempty"`
	// Number of users who gave input in *this* report interval.
	Active *uint32 `protobuf:"varint,3,req,name=active" json:"active,omitempty"`
	// User activity is reported in a histographic fashion via a
	// 1D histogram, which record the number of users who gave
	// any sort of input in the last (now - x) milliseconds.
	Qgram            []*HistogramUint1D `protobuf:"bytes,4,rep,name=qgram" json:"qgram,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *Report_Users) Reset()                    { *m = Report_Users{} }
func (m *Report_Users) String() string            { return proto.CompactTextString(m) }
func (*Report_Users) ProtoMessage()               {}
func (*Report_Users) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

func (m *Report_Users) GetConnected() uint32 {
	if m != nil && m.Connected != nil {
		return *m.Connected
	}
	return 0
}

func (m *Report_Users) GetQuorum() uint32 {
	if m != nil && m.Quorum != nil {
		return *m.Quorum
	}
	return 0
}

func (m *Report_Users) GetActive() uint32 {
	if m != nil && m.Active != nil {
		return *m.Active
	}
	return 0
}

func (m *Report_Users) GetQgram() []*HistogramUint1D {
	if m != nil {
		return m.Qgram
	}
	return nil
}

// Reports for the Joystick input type.
type Report_JoystickInfo struct {
	// The id of this Joystick defined in the control editor/ Interactive Game Schema
	Id *uint32 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	// Average of all the user's positions
	CoordMean *Coordinate `protobuf:"bytes,2,opt,name=coordMean" json:"coordMean,omitempty"`
	// Standard deviation of the above coordMean
	CoordStddev      *Coordinate `protobuf:"bytes,3,opt,name=coordStddev" json:"coordStddev,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Report_JoystickInfo) Reset()                    { *m = Report_JoystickInfo{} }
func (m *Report_JoystickInfo) String() string            { return proto.CompactTextString(m) }
func (*Report_JoystickInfo) ProtoMessage()               {}
func (*Report_JoystickInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 1} }

func (m *Report_JoystickInfo) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Report_JoystickInfo) GetCoordMean() *Coordinate {
	if m != nil {
		return m.CoordMean
	}
	return nil
}

func (m *Report_JoystickInfo) GetCoordStddev() *Coordinate {
	if m != nil {
		return m.CoordStddev
	}
	return nil
}

// Reports for the Tactile input type.
type Report_TactileInfo struct {
	// The id of this Tactile defined in the control editor/ Interactive Game Schema
	Id *uint32 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	// Number of users holding this tactile in the report interval
	Holding *float64 `protobuf:"fixed64,2,opt,name=holding" json:"holding,omitempty"`
	// Number of users pressing the tactile in this report interval
	PressFrequency *float64 `protobuf:"fixed64,3,opt,name=pressFrequency" json:"pressFrequency,omitempty"`
	// Number of users releasing the tactile in this report interval
	ReleaseFrequency *float64 `protobuf:"fixed64,4,opt,name=releaseFrequency" json:"releaseFrequency,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Report_TactileInfo) Reset()                    { *m = Report_TactileInfo{} }
func (m *Report_TactileInfo) String() string            { return proto.CompactTextString(m) }
func (*Report_TactileInfo) ProtoMessage()               {}
func (*Report_TactileInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 2} }

func (m *Report_TactileInfo) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Report_TactileInfo) GetHolding() float64 {
	if m != nil && m.Holding != nil {
		return *m.Holding
	}
	return 0
}

func (m *Report_TactileInfo) GetPressFrequency() float64 {
	if m != nil && m.PressFrequency != nil {
		return *m.PressFrequency
	}
	return 0
}

func (m *Report_TactileInfo) GetReleaseFrequency() float64 {
	if m != nil && m.ReleaseFrequency != nil {
		return *m.ReleaseFrequency
	}
	return 0
}

// Reports for the Screen input type.
type Report_ScreenInfo struct {
	// The id of this Screen defined in the control editor/ Interactive Game Schema
	Id *uint32 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	// The number of clicks users made this analysis cycle.
	Clicks *float64 `protobuf:"fixed64,2,opt,name=clicks" json:"clicks,omitempty"`
	// Average of all the user's positions
	CoordMean *Coordinate `protobuf:"bytes,3,opt,name=coordMean" json:"coordMean,omitempty"`
	// Standard deviation of the above coordMean
	CoordStddev      *Coordinate `protobuf:"bytes,4,opt,name=coordStddev" json:"coordStddev,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Report_ScreenInfo) Reset()                    { *m = Report_ScreenInfo{} }
func (m *Report_ScreenInfo) String() string            { return proto.CompactTextString(m) }
func (*Report_ScreenInfo) ProtoMessage()               {}
func (*Report_ScreenInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 3} }

func (m *Report_ScreenInfo) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Report_ScreenInfo) GetClicks() float64 {
	if m != nil && m.Clicks != nil {
		return *m.Clicks
	}
	return 0
}

func (m *Report_ScreenInfo) GetCoordMean() *Coordinate {
	if m != nil {
		return m.CoordMean
	}
	return nil
}

func (m *Report_ScreenInfo) GetCoordStddev() *Coordinate {
	if m != nil {
		return m.CoordStddev
	}
	return nil
}

// An error in response to some invalid input or event.
type Error struct {
	// An error message
	Message          *string `protobuf:"bytes,1,req,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Error) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

// A ProgressUpdate message may be sent up periodically from
// the Robot. It contains an array of objects to update the
// multiple controls on the frontend.
type ProgressUpdate struct {
	// State to change to. States with the given state in their `states` array
	// will be visible. If not passed, the state will not be changed.
	// The default state at initialization of the robot is simply "default".
	State            *string                          `protobuf:"bytes,3,opt,name=state" json:"state,omitempty"`
	Joystick         []*ProgressUpdate_JoystickUpdate `protobuf:"bytes,1,rep,name=joystick" json:"joystick,omitempty"`
	Tactile          []*ProgressUpdate_TactileUpdate  `protobuf:"bytes,2,rep,name=tactile" json:"tactile,omitempty"`
	Screen           []*ProgressUpdate_ScreenUpdate   `protobuf:"bytes,4,rep,name=screen" json:"screen,omitempty"`
	XXX_unrecognized []byte                           `json:"-"`
}

func (m *ProgressUpdate) Reset()                    { *m = ProgressUpdate{} }
func (m *ProgressUpdate) String() string            { return proto.CompactTextString(m) }
func (*ProgressUpdate) ProtoMessage()               {}
func (*ProgressUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ProgressUpdate) GetState() string {
	if m != nil && m.State != nil {
		return *m.State
	}
	return ""
}

func (m *ProgressUpdate) GetJoystick() []*ProgressUpdate_JoystickUpdate {
	if m != nil {
		return m.Joystick
	}
	return nil
}

func (m *ProgressUpdate) GetTactile() []*ProgressUpdate_TactileUpdate {
	if m != nil {
		return m.Tactile
	}
	return nil
}

func (m *ProgressUpdate) GetScreen() []*ProgressUpdate_ScreenUpdate {
	if m != nil {
		return m.Screen
	}
	return nil
}

type ProgressUpdate_JoystickUpdate struct {
	// The ID of the joystick control to update
	Id *uint32 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	// The angle to move the "pointer" that appears around the joystick
	// to. This is usually used to indicate the average direction that
	// users pointing to. This is given in radians, in the range
	// [0, 2π), with the same alignment as the standard unit circle.
	Angle *float64 `protobuf:"fixed64,2,opt,name=angle" json:"angle,omitempty"`
	// Intensity the pointer should appear at. This is often used to
	// indicate how strongly users are moving in a direction.
	// Should be given in the range [0, 1].
	Intensity *float64 `protobuf:"fixed64,3,opt,name=intensity" json:"intensity,omitempty"`
	// Changes the disabled or enabled state of the control. If you pass
	// `disabled = true` in a progress update, users won't be able to
	// give input on that control until you send `disabled = false`.
	Disabled         *bool  `protobuf:"varint,4,opt,name=disabled" json:"disabled,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ProgressUpdate_JoystickUpdate) Reset()         { *m = ProgressUpdate_JoystickUpdate{} }
func (m *ProgressUpdate_JoystickUpdate) String() string { return proto.CompactTextString(m) }
func (*ProgressUpdate_JoystickUpdate) ProtoMessage()    {}
func (*ProgressUpdate_JoystickUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0}
}

func (m *ProgressUpdate_JoystickUpdate) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *ProgressUpdate_JoystickUpdate) GetAngle() float64 {
	if m != nil && m.Angle != nil {
		return *m.Angle
	}
	return 0
}

func (m *ProgressUpdate_JoystickUpdate) GetIntensity() float64 {
	if m != nil && m.Intensity != nil {
		return *m.Intensity
	}
	return 0
}

func (m *ProgressUpdate_JoystickUpdate) GetDisabled() bool {
	if m != nil && m.Disabled != nil {
		return *m.Disabled
	}
	return false
}

type ProgressUpdate_TactileUpdate struct {
	// The ID of the tactile control to update
	Id *uint32 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	// Starts a cooldown for all users, with a duration given in milliseconds.
	// Users will not be able to press the button until the cooldown is
	// over. Users who currently are pressing the button will be marked
	// as having released it. Sending another cooldown before the first
	// is over sets the cooldown's duration. The cooldown duration will
	// decrement automatically.
	Cooldown *uint32 `protobuf:"varint,2,opt,name=cooldown" json:"cooldown,omitempty"`
	// Marks the button has having been fired, showing a "pulse"
	// on the Beam frontend.
	Fired *bool `protobuf:"varint,3,opt,name=fired" json:"fired,omitempty"`
	// Sets the progress of the button toward some threshold, appearing
	// as a sort of progress bar on the frontend. Should be given in the
	// range [0, 1].
	Progress *float64 `protobuf:"fixed64,4,opt,name=progress" json:"progress,omitempty"`
	// Changes the disabled or enabled state of the control. If you pass
	// `disabled = true` in a progress update, users won't be able to
	// give input on that control until you send `disabled = false`.
	Disabled         *bool  `protobuf:"varint,5,opt,name=disabled" json:"disabled,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ProgressUpdate_TactileUpdate) Reset()                    { *m = ProgressUpdate_TactileUpdate{} }
func (m *ProgressUpdate_TactileUpdate) String() string            { return proto.CompactTextString(m) }
func (*ProgressUpdate_TactileUpdate) ProtoMessage()               {}
func (*ProgressUpdate_TactileUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 1} }

func (m *ProgressUpdate_TactileUpdate) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *ProgressUpdate_TactileUpdate) GetCooldown() uint32 {
	if m != nil && m.Cooldown != nil {
		return *m.Cooldown
	}
	return 0
}

func (m *ProgressUpdate_TactileUpdate) GetFired() bool {
	if m != nil && m.Fired != nil {
		return *m.Fired
	}
	return false
}

func (m *ProgressUpdate_TactileUpdate) GetProgress() float64 {
	if m != nil && m.Progress != nil {
		return *m.Progress
	}
	return 0
}

func (m *ProgressUpdate_TactileUpdate) GetDisabled() bool {
	if m != nil && m.Disabled != nil {
		return *m.Disabled
	}
	return false
}

type ProgressUpdate_ScreenUpdate struct {
	// The ID of the screen control to update
	Id *uint32 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	// A list of clicks that will be displayed on the frontend as pulses
	// on the screen. You can show multiple pulses per cycle.
	Clicks []*ProgressUpdate_ScreenUpdate_Click `protobuf:"bytes,2,rep,name=clicks" json:"clicks,omitempty"`
	// Changes the disabled or enabled state of the control. If you pass
	// `disabled = true` in a progress update, users won't be able to
	// give input on that control until you send `disabled = false`.
	Disabled         *bool  `protobuf:"varint,3,opt,name=disabled" json:"disabled,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ProgressUpdate_ScreenUpdate) Reset()                    { *m = ProgressUpdate_ScreenUpdate{} }
func (m *ProgressUpdate_ScreenUpdate) String() string            { return proto.CompactTextString(m) }
func (*ProgressUpdate_ScreenUpdate) ProtoMessage()               {}
func (*ProgressUpdate_ScreenUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 2} }

func (m *ProgressUpdate_ScreenUpdate) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *ProgressUpdate_ScreenUpdate) GetClicks() []*ProgressUpdate_ScreenUpdate_Click {
	if m != nil {
		return m.Clicks
	}
	return nil
}

func (m *ProgressUpdate_ScreenUpdate) GetDisabled() bool {
	if m != nil && m.Disabled != nil {
		return *m.Disabled
	}
	return false
}

type ProgressUpdate_ScreenUpdate_Click struct {
	// x and y follow the same coordinate system as described in
	// Report.ScreenInfo .
	Coordinate *Coordinate `protobuf:"bytes,1,req,name=coordinate" json:"coordinate,omitempty"`
	// Intensity of the pulse from 0 to 1.
	Intensity        *float64 `protobuf:"fixed64,2,req,name=intensity" json:"intensity,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ProgressUpdate_ScreenUpdate_Click) Reset()         { *m = ProgressUpdate_ScreenUpdate_Click{} }
func (m *ProgressUpdate_ScreenUpdate_Click) String() string { return proto.CompactTextString(m) }
func (*ProgressUpdate_ScreenUpdate_Click) ProtoMessage()    {}
func (*ProgressUpdate_ScreenUpdate_Click) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 2, 0}
}

func (m *ProgressUpdate_ScreenUpdate_Click) GetCoordinate() *Coordinate {
	if m != nil {
		return m.Coordinate
	}
	return nil
}

func (m *ProgressUpdate_ScreenUpdate_Click) GetIntensity() float64 {
	if m != nil && m.Intensity != nil {
		return *m.Intensity
	}
	return 0
}

// HistogramUint1D is a point on a 1-dimensional histogram, where `x` is the
// defined horizontal axis and y is the vertical axis.
type HistogramUint1D struct {
	X                *uint32 `protobuf:"varint,1,req,name=x" json:"x,omitempty"`
	Y                *uint32 `protobuf:"varint,2,req,name=y" json:"y,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *HistogramUint1D) Reset()                    { *m = HistogramUint1D{} }
func (m *HistogramUint1D) String() string            { return proto.CompactTextString(m) }
func (*HistogramUint1D) ProtoMessage()               {}
func (*HistogramUint1D) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *HistogramUint1D) GetX() uint32 {
	if m != nil && m.X != nil {
		return *m.X
	}
	return 0
}

func (m *HistogramUint1D) GetY() uint32 {
	if m != nil && m.Y != nil {
		return *m.Y
	}
	return 0
}

// Coordinate represents a single x/y point on a screen or joystick.
type Coordinate struct {
	X                *float64 `protobuf:"fixed64,1,req,name=x" json:"x,omitempty"`
	Y                *float64 `protobuf:"fixed64,2,req,name=y" json:"y,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Coordinate) Reset()                    { *m = Coordinate{} }
func (m *Coordinate) String() string            { return proto.CompactTextString(m) }
func (*Coordinate) ProtoMessage()               {}
func (*Coordinate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Coordinate) GetX() float64 {
	if m != nil && m.X != nil {
		return *m.X
	}
	return 0
}

func (m *Coordinate) GetY() float64 {
	if m != nil && m.Y != nil {
		return *m.Y
	}
	return 0
}

func init() {
	proto.RegisterType((*Handshake)(nil), "gobeam.Handshake")
	proto.RegisterType((*HandshakeACK)(nil), "gobeam.HandshakeACK")
	proto.RegisterType((*Report)(nil), "gobeam.Report")
	proto.RegisterType((*Report_Users)(nil), "gobeam.Report.Users")
	proto.RegisterType((*Report_JoystickInfo)(nil), "gobeam.Report.JoystickInfo")
	proto.RegisterType((*Report_TactileInfo)(nil), "gobeam.Report.TactileInfo")
	proto.RegisterType((*Report_ScreenInfo)(nil), "gobeam.Report.ScreenInfo")
	proto.RegisterType((*Error)(nil), "gobeam.Error")
	proto.RegisterType((*ProgressUpdate)(nil), "gobeam.ProgressUpdate")
	proto.RegisterType((*ProgressUpdate_JoystickUpdate)(nil), "gobeam.ProgressUpdate.JoystickUpdate")
	proto.RegisterType((*ProgressUpdate_TactileUpdate)(nil), "gobeam.ProgressUpdate.TactileUpdate")
	proto.RegisterType((*ProgressUpdate_ScreenUpdate)(nil), "gobeam.ProgressUpdate.ScreenUpdate")
	proto.RegisterType((*ProgressUpdate_ScreenUpdate_Click)(nil), "gobeam.ProgressUpdate.ScreenUpdate.Click")
	proto.RegisterType((*HistogramUint1D)(nil), "gobeam.HistogramUint1D")
	proto.RegisterType((*Coordinate)(nil), "gobeam.Coordinate")
}

var fileDescriptor0 = []byte{
	// 713 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x54, 0xdd, 0x6a, 0x13, 0x4d,
	0x18, 0x66, 0x92, 0x6c, 0xda, 0xbc, 0x6d, 0xf2, 0x7d, 0x0c, 0x45, 0x63, 0xf4, 0xa0, 0xc6, 0x1f,
	0xaa, 0xd0, 0x60, 0x8b, 0xe0, 0x81, 0x20, 0x94, 0xa8, 0x54, 0x8b, 0x20, 0x53, 0x7b, 0xe0, 0xe1,
	0x76, 0x77, 0x9a, 0xae, 0xdd, 0xec, 0xa6, 0x33, 0x93, 0xda, 0x9c, 0x8b, 0x20, 0xde, 0x82, 0xe7,
	0x5e, 0x86, 0xb7, 0xe1, 0xe5, 0xf8, 0xce, 0xcf, 0xfe, 0xc6, 0x42, 0xf1, 0x6c, 0x9f, 0x99, 0xe7,
	0x79, 0xe7, 0x79, 0xff, 0x16, 0xe0, 0x98, 0xfb, 0xd3, 0xd1, 0x4c, 0xa4, 0x2a, 0xa5, 0xed, 0x49,
	0xaa, 0xd1, 0x70, 0x0c, 0x9d, 0x7d, 0x3f, 0x09, 0xe5, 0xa9, 0x7f, 0xc6, 0x69, 0x1f, 0x56, 0x82,
	0x53, 0x3f, 0x49, 0x78, 0xdc, 0x27, 0x9b, 0x8d, 0xad, 0x2e, 0xcb, 0x20, 0xbd, 0x03, 0x1d, 0xa9,
	0x04, 0x0a, 0x0e, 0xf8, 0xa2, 0xdf, 0xc0, 0xbb, 0x0e, 0x2b, 0x0e, 0x86, 0x3d, 0x58, 0xcf, 0x83,
	0xec, 0x8d, 0x0f, 0x86, 0x3f, 0xdb, 0xd0, 0x66, 0x7c, 0x96, 0x0a, 0x45, 0x29, 0xb4, 0x54, 0x34,
	0xe5, 0x2e, 0x9e, 0xf9, 0xa6, 0x8f, 0xc1, 0x9b, 0x4b, 0x2e, 0xa4, 0x09, 0xb4, 0xb6, 0xbb, 0x31,
	0xb2, 0x5e, 0x46, 0x56, 0x32, 0x3a, 0xd2, 0x77, 0xcc, 0x52, 0xe8, 0x33, 0x58, 0xfd, 0x94, 0x2e,
	0xa4, 0x8a, 0x82, 0xb3, 0x7e, 0x73, 0xb3, 0x89, 0xf4, 0xdb, 0x35, 0xfa, 0x5b, 0x77, 0xfd, 0x26,
	0x39, 0x49, 0x59, 0x4e, 0xa6, 0x4f, 0x61, 0x45, 0xf9, 0x81, 0x8a, 0x62, 0xde, 0x6f, 0x19, 0xdd,
	0xa0, 0xa6, 0xfb, 0x60, 0x6f, 0x8d, 0x2c, 0xa3, 0xd2, 0x1d, 0x68, 0xcb, 0x40, 0x70, 0x9e, 0xf4,
	0x3d, 0x23, 0xba, 0x55, 0x13, 0x1d, 0x9a, 0x4b, 0xa3, 0x71, 0xc4, 0xc1, 0x17, 0x02, 0x9e, 0xb1,
	0xac, 0x8b, 0x14, 0xa4, 0x58, 0xae, 0x40, 0xf1, 0xd0, 0x25, 0x5c, 0x1c, 0xd0, 0x1b, 0xd0, 0x3e,
	0x9f, 0xa7, 0x62, 0x3e, 0x35, 0x69, 0x77, 0x99, 0x43, 0xfa, 0x5c, 0x3f, 0x7e, 0xc1, 0x31, 0x3f,
	0x73, 0x6e, 0x11, 0xdd, 0x06, 0xef, 0x7c, 0x22, 0xfc, 0xa9, 0xb3, 0x7f, 0x33, 0x73, 0xb2, 0x1f,
	0x49, 0x95, 0xea, 0x8b, 0xa3, 0x28, 0x51, 0x3b, 0x2f, 0x99, 0x65, 0x0d, 0xbe, 0x12, 0x58, 0x2f,
	0x97, 0x82, 0xf6, 0xa0, 0x11, 0x65, 0x36, 0xf0, 0x8b, 0x3e, 0xd1, 0xee, 0x52, 0x11, 0xbe, 0xe3,
	0x7e, 0x82, 0x16, 0x08, 0xc6, 0xa4, 0x59, 0xcc, 0xb1, 0xbe, 0x88, 0x12, 0x5f, 0x71, 0x56, 0x90,
	0xb0, 0x84, 0x6b, 0x06, 0x1c, 0xaa, 0x30, 0xe4, 0x17, 0x68, 0xef, 0x2a, 0x4d, 0x99, 0x36, 0xf8,
	0x4e, 0x60, 0xad, 0x54, 0xdb, 0x25, 0x1f, 0x38, 0x64, 0xa7, 0x69, 0x8c, 0xca, 0x89, 0x71, 0x41,
	0x58, 0x06, 0xe9, 0x43, 0xe8, 0xcd, 0x04, 0x97, 0xf2, 0xb5, 0xe0, 0xe7, 0x73, 0x9e, 0x04, 0x0b,
	0xf3, 0x24, 0x61, 0xb5, 0x53, 0x9c, 0x9f, 0xff, 0x05, 0x8f, 0xb9, 0x2f, 0x79, 0xc1, 0x6c, 0x19,
	0xe6, 0xd2, 0xf9, 0xe0, 0x07, 0x01, 0x28, 0x9a, 0xb6, 0x64, 0x06, 0x8b, 0x1f, 0xc4, 0x58, 0x31,
	0xe9, 0xbc, 0x38, 0x54, 0x2d, 0x56, 0xf3, 0x1f, 0x8a, 0xd5, 0xba, 0x56, 0xb1, 0x86, 0x77, 0xc1,
	0x7b, 0x25, 0x44, 0x2a, 0x74, 0x55, 0xa6, 0x98, 0xa4, 0x3f, 0xb1, 0xab, 0xd2, 0x61, 0x19, 0x1c,
	0xfe, 0xf2, 0xa0, 0xf7, 0x5e, 0x60, 0xc7, 0x11, 0x1f, 0xcd, 0x42, 0x0c, 0x41, 0x37, 0xc0, 0x93,
	0x0a, 0x3f, 0x8c, 0xb3, 0x0e, 0xb3, 0x80, 0xee, 0x95, 0x56, 0x85, 0x98, 0x99, 0x79, 0x90, 0x3d,
	0x5f, 0xd5, 0xe7, 0x2b, 0x63, 0x61, 0x69, 0x69, 0x5e, 0x14, 0x4b, 0xd3, 0x30, 0x11, 0xee, 0x5f,
	0x11, 0xc1, 0x35, 0xd8, 0x05, 0xc8, 0xd7, 0xe7, 0x79, 0xbe, 0x3e, 0x76, 0x68, 0xef, 0x5d, 0x21,
	0xb7, 0x1d, 0x71, 0xea, 0x6c, 0x91, 0x66, 0xd0, 0xab, 0x1a, 0x5b, 0xea, 0x16, 0xe6, 0xed, 0x27,
	0x13, 0x63, 0x4e, 0x37, 0xcb, 0x02, 0xbd, 0x76, 0xb8, 0x09, 0x3c, 0x91, 0x91, 0xca, 0x26, 0xa6,
	0x38, 0xa0, 0x03, 0x58, 0x0d, 0x23, 0xe9, 0x1f, 0xc7, 0xb8, 0x93, 0xba, 0x29, 0xab, 0x2c, 0xc7,
	0x83, 0x6f, 0x04, 0xba, 0x95, 0x4c, 0x96, 0x5e, 0x44, 0x35, 0xb6, 0x2b, 0x0e, 0xd3, 0xcf, 0x76,
	0x67, 0xba, 0x2c, 0xc7, 0xda, 0xcd, 0x49, 0x24, 0x30, 0x6c, 0xd3, 0x84, 0xb5, 0x40, 0x2b, 0x66,
	0x2e, 0x59, 0x37, 0x94, 0x39, 0xae, 0x78, 0xf1, 0x6a, 0x5e, 0x7e, 0xe3, 0xfe, 0x96, 0xcb, 0xb2,
	0x64, 0x65, 0xaf, 0x34, 0xaa, 0xba, 0xb6, 0x8f, 0xae, 0x51, 0xdb, 0xd1, 0x58, 0x2b, 0xf2, 0xa9,
	0x2e, 0xbf, 0xdf, 0xac, 0xbd, 0xff, 0x11, 0x3c, 0x43, 0xa6, 0xbb, 0x00, 0x41, 0x3e, 0xad, 0xe6,
	0xfd, 0xbf, 0xcf, 0x71, 0x89, 0x55, 0x6d, 0x81, 0xfe, 0xbd, 0x95, 0x5b, 0x30, 0xdc, 0x86, 0xff,
	0x6a, 0x3f, 0x2d, 0xba, 0x0e, 0xe4, 0xd2, 0xe5, 0x46, 0x2e, 0x35, 0x5a, 0xb8, 0xbf, 0x22, 0x59,
	0x0c, 0xb7, 0x00, 0x8a, 0x67, 0x0a, 0x26, 0xa9, 0x30, 0x11, 0x2d, 0xfe, 0x04, 0x00, 0x00, 0xff,
	0xff, 0xf9, 0xc1, 0x03, 0xc7, 0xd1, 0x06, 0x00, 0x00,
}
