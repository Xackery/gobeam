// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: beam.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Gobeam {

  /// <summary>Holder for reflection information generated from beam.proto</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class BeamReflection {

    #region Descriptor
    /// <summary>File descriptor for beam.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static BeamReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CgpiZWFtLnByb3RvEgZnb2JlYW0iLwoJSGFuZHNoYWtlEg8KB2NoYW5uZWwY",
            "ASABKA0SEQoJc3RyZWFtS2V5GAIgASgJIg4KDEhhbmRzaGFrZUFDSyLqBAoG",
            "UmVwb3J0EgwKBHRpbWUYASABKA0SIwoFdXNlcnMYAiABKAsyFC5nb2JlYW0u",
            "UmVwb3J0LlVzZXJzEi0KCGpveXN0aWNrGAMgAygLMhsuZ29iZWFtLlJlcG9y",
            "dC5Kb3lzdGlja0luZm8SKwoHdGFjdGlsZRgEIAMoCzIaLmdvYmVhbS5SZXBv",
            "cnQuVGFjdGlsZUluZm8SKQoGc2NyZWVuGAUgAygLMhkuZ29iZWFtLlJlcG9y",
            "dC5TY3JlZW5JbmZvGmIKBVVzZXJzEhEKCWNvbm5lY3RlZBgBIAEoDRIOCgZx",
            "dW9ydW0YAiABKA0SDgoGYWN0aXZlGAMgASgNEiYKBXFncmFtGAQgAygLMhcu",
            "Z29iZWFtLkhpc3RvZ3JhbVVpbnQxRBpqCgxKb3lzdGlja0luZm8SCgoCaWQY",
            "ASABKA0SJQoJY29vcmRNZWFuGAIgASgLMhIuZ29iZWFtLkNvb3JkaW5hdGUS",
            "JwoLY29vcmRTdGRkZXYYAyABKAsyEi5nb2JlYW0uQ29vcmRpbmF0ZRpcCgtU",
            "YWN0aWxlSW5mbxIKCgJpZBgBIAEoDRIPCgdob2xkaW5nGAIgASgBEhYKDnBy",
            "ZXNzRnJlcXVlbmN5GAMgASgBEhgKEHJlbGVhc2VGcmVxdWVuY3kYBCABKAEa",
            "eAoKU2NyZWVuSW5mbxIKCgJpZBgBIAEoDRIOCgZjbGlja3MYAiABKAESJQoJ",
            "Y29vcmRNZWFuGAMgASgLMhIuZ29iZWFtLkNvb3JkaW5hdGUSJwoLY29vcmRT",
            "dGRkZXYYBCABKAsyEi5nb2JlYW0uQ29vcmRpbmF0ZSIYCgVFcnJvchIPCgdt",
            "ZXNzYWdlGAEgASgJIqYECg5Qcm9ncmVzc1VwZGF0ZRINCgVzdGF0ZRgDIAEo",
            "CRI3Cghqb3lzdGljaxgBIAMoCzIlLmdvYmVhbS5Qcm9ncmVzc1VwZGF0ZS5K",
            "b3lzdGlja1VwZGF0ZRI1Cgd0YWN0aWxlGAIgAygLMiQuZ29iZWFtLlByb2dy",
            "ZXNzVXBkYXRlLlRhY3RpbGVVcGRhdGUSMwoGc2NyZWVuGAQgAygLMiMuZ29i",
            "ZWFtLlByb2dyZXNzVXBkYXRlLlNjcmVlblVwZGF0ZRpQCg5Kb3lzdGlja1Vw",
            "ZGF0ZRIKCgJpZBgBIAEoDRINCgVhbmdsZRgCIAEoARIRCglpbnRlbnNpdHkY",
            "AyABKAESEAoIZGlzYWJsZWQYBCABKAgaYAoNVGFjdGlsZVVwZGF0ZRIKCgJp",
            "ZBgBIAEoDRIQCghjb29sZG93bhgCIAEoDRINCgVmaXJlZBgDIAEoCBIQCghw",
            "cm9ncmVzcxgEIAEoARIQCghkaXNhYmxlZBgFIAEoCBqrAQoMU2NyZWVuVXBk",
            "YXRlEgoKAmlkGAEgASgNEjkKBmNsaWNrcxgCIAMoCzIpLmdvYmVhbS5Qcm9n",
            "cmVzc1VwZGF0ZS5TY3JlZW5VcGRhdGUuQ2xpY2sSEAoIZGlzYWJsZWQYAyAB",
            "KAgaQgoFQ2xpY2sSJgoKY29vcmRpbmF0ZRgBIAEoCzISLmdvYmVhbS5Db29y",
            "ZGluYXRlEhEKCWludGVuc2l0eRgCIAEoASInCg9IaXN0b2dyYW1VaW50MUQS",
            "CQoBeBgBIAEoDRIJCgF5GAIgASgNIiIKCkNvb3JkaW5hdGUSCQoBeBgBIAEo",
            "ARIJCgF5GAIgASgBYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.Handshake), global::Gobeam.Handshake.Parser, new[]{ "Channel", "StreamKey" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.HandshakeACK), global::Gobeam.HandshakeACK.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.Report), global::Gobeam.Report.Parser, new[]{ "Time", "Users", "Joystick", "Tactile", "Screen" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.Report.Types.Users), global::Gobeam.Report.Types.Users.Parser, new[]{ "Connected", "Quorum", "Active", "Qgram" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.Report.Types.JoystickInfo), global::Gobeam.Report.Types.JoystickInfo.Parser, new[]{ "Id", "CoordMean", "CoordStddev" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.Report.Types.TactileInfo), global::Gobeam.Report.Types.TactileInfo.Parser, new[]{ "Id", "Holding", "PressFrequency", "ReleaseFrequency" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.Report.Types.ScreenInfo), global::Gobeam.Report.Types.ScreenInfo.Parser, new[]{ "Id", "Clicks", "CoordMean", "CoordStddev" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.Error), global::Gobeam.Error.Parser, new[]{ "Message" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.ProgressUpdate), global::Gobeam.ProgressUpdate.Parser, new[]{ "State", "Joystick", "Tactile", "Screen" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.ProgressUpdate.Types.JoystickUpdate), global::Gobeam.ProgressUpdate.Types.JoystickUpdate.Parser, new[]{ "Id", "Angle", "Intensity", "Disabled" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.ProgressUpdate.Types.TactileUpdate), global::Gobeam.ProgressUpdate.Types.TactileUpdate.Parser, new[]{ "Id", "Cooldown", "Fired", "Progress", "Disabled" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.ProgressUpdate.Types.ScreenUpdate), global::Gobeam.ProgressUpdate.Types.ScreenUpdate.Parser, new[]{ "Id", "Clicks", "Disabled" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.ProgressUpdate.Types.ScreenUpdate.Types.Click), global::Gobeam.ProgressUpdate.Types.ScreenUpdate.Types.Click.Parser, new[]{ "Coordinate", "Intensity" }, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.HistogramUint1D), global::Gobeam.HistogramUint1D.Parser, new[]{ "X", "Y" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Gobeam.Coordinate), global::Gobeam.Coordinate.Parser, new[]{ "X", "Y" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///  Handshake MUST be the first message sent from clients to servers.
  ///  After sending it, they should wait for a HandshakeACK, which will
  ///  contain authentication status.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Handshake : pb::IMessage<Handshake> {
    private static readonly pb::MessageParser<Handshake> _parser = new pb::MessageParser<Handshake>(() => new Handshake());
    public static pb::MessageParser<Handshake> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Gobeam.BeamReflection.Descriptor.MessageTypes[0]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public Handshake() {
      OnConstruction();
    }

    partial void OnConstruction();

    public Handshake(Handshake other) : this() {
      channel_ = other.channel_;
      streamKey_ = other.streamKey_;
    }

    public Handshake Clone() {
      return new Handshake(this);
    }

    /// <summary>Field number for the "channel" field.</summary>
    public const int ChannelFieldNumber = 1;
    private uint channel_;
    /// <summary>
    ///  Channel ID you want to connect as.
    /// </summary>
    public uint Channel {
      get { return channel_; }
      set {
        channel_ = value;
      }
    }

    /// <summary>Field number for the "streamKey" field.</summary>
    public const int StreamKeyFieldNumber = 2;
    private string streamKey_ = "";
    /// <summary>
    ///  That channel's stream key
    /// </summary>
    public string StreamKey {
      get { return streamKey_; }
      set {
        streamKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    public override bool Equals(object other) {
      return Equals(other as Handshake);
    }

    public bool Equals(Handshake other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Channel != other.Channel) return false;
      if (StreamKey != other.StreamKey) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Channel != 0) hash ^= Channel.GetHashCode();
      if (StreamKey.Length != 0) hash ^= StreamKey.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Channel != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Channel);
      }
      if (StreamKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(StreamKey);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Channel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Channel);
      }
      if (StreamKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StreamKey);
      }
      return size;
    }

    public void MergeFrom(Handshake other) {
      if (other == null) {
        return;
      }
      if (other.Channel != 0) {
        Channel = other.Channel;
      }
      if (other.StreamKey.Length != 0) {
        StreamKey = other.StreamKey;
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Channel = input.ReadUInt32();
            break;
          }
          case 18: {
            StreamKey = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  This is sent from the server to the client in response to a
  ///  Handshake message. It's only send on a successful handshake.
  ///  In other cases, an error will be sent.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class HandshakeACK : pb::IMessage<HandshakeACK> {
    private static readonly pb::MessageParser<HandshakeACK> _parser = new pb::MessageParser<HandshakeACK>(() => new HandshakeACK());
    public static pb::MessageParser<HandshakeACK> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Gobeam.BeamReflection.Descriptor.MessageTypes[1]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public HandshakeACK() {
      OnConstruction();
    }

    partial void OnConstruction();

    public HandshakeACK(HandshakeACK other) : this() {
    }

    public HandshakeACK Clone() {
      return new HandshakeACK(this);
    }

    public override bool Equals(object other) {
      return Equals(other as HandshakeACK);
    }

    public bool Equals(HandshakeACK other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
    }

    public int CalculateSize() {
      int size = 0;
      return size;
    }

    public void MergeFrom(HandshakeACK other) {
      if (other == null) {
        return;
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  /// <summary>
  ///  The Report is send down to the streamer's computer at the
  ///  reportFrequency, containing information about connected
  ///  clients and their actions.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Report : pb::IMessage<Report> {
    private static readonly pb::MessageParser<Report> _parser = new pb::MessageParser<Report>(() => new Report());
    public static pb::MessageParser<Report> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Gobeam.BeamReflection.Descriptor.MessageTypes[2]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public Report() {
      OnConstruction();
    }

    partial void OnConstruction();

    public Report(Report other) : this() {
      time_ = other.time_;
      Users = other.users_ != null ? other.Users.Clone() : null;
      joystick_ = other.joystick_.Clone();
      tactile_ = other.tactile_.Clone();
      screen_ = other.screen_.Clone();
    }

    public Report Clone() {
      return new Report(this);
    }

    /// <summary>Field number for the "time" field.</summary>
    public const int TimeFieldNumber = 1;
    private uint time_;
    /// <summary>
    ///  Time since start of connection in seconds
    /// </summary>
    public uint Time {
      get { return time_; }
      set {
        time_ = value;
      }
    }

    /// <summary>Field number for the "users" field.</summary>
    public const int UsersFieldNumber = 2;
    private global::Gobeam.Report.Types.Users users_;
    public global::Gobeam.Report.Types.Users Users {
      get { return users_; }
      set {
        users_ = value;
      }
    }

    /// <summary>Field number for the "joystick" field.</summary>
    public const int JoystickFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Gobeam.Report.Types.JoystickInfo> _repeated_joystick_codec
        = pb::FieldCodec.ForMessage(26, global::Gobeam.Report.Types.JoystickInfo.Parser);
    private readonly pbc::RepeatedField<global::Gobeam.Report.Types.JoystickInfo> joystick_ = new pbc::RepeatedField<global::Gobeam.Report.Types.JoystickInfo>();
    public pbc::RepeatedField<global::Gobeam.Report.Types.JoystickInfo> Joystick {
      get { return joystick_; }
    }

    /// <summary>Field number for the "tactile" field.</summary>
    public const int TactileFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Gobeam.Report.Types.TactileInfo> _repeated_tactile_codec
        = pb::FieldCodec.ForMessage(34, global::Gobeam.Report.Types.TactileInfo.Parser);
    private readonly pbc::RepeatedField<global::Gobeam.Report.Types.TactileInfo> tactile_ = new pbc::RepeatedField<global::Gobeam.Report.Types.TactileInfo>();
    public pbc::RepeatedField<global::Gobeam.Report.Types.TactileInfo> Tactile {
      get { return tactile_; }
    }

    /// <summary>Field number for the "screen" field.</summary>
    public const int ScreenFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Gobeam.Report.Types.ScreenInfo> _repeated_screen_codec
        = pb::FieldCodec.ForMessage(42, global::Gobeam.Report.Types.ScreenInfo.Parser);
    private readonly pbc::RepeatedField<global::Gobeam.Report.Types.ScreenInfo> screen_ = new pbc::RepeatedField<global::Gobeam.Report.Types.ScreenInfo>();
    public pbc::RepeatedField<global::Gobeam.Report.Types.ScreenInfo> Screen {
      get { return screen_; }
    }

    public override bool Equals(object other) {
      return Equals(other as Report);
    }

    public bool Equals(Report other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Time != other.Time) return false;
      if (!object.Equals(Users, other.Users)) return false;
      if(!joystick_.Equals(other.joystick_)) return false;
      if(!tactile_.Equals(other.tactile_)) return false;
      if(!screen_.Equals(other.screen_)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Time != 0) hash ^= Time.GetHashCode();
      if (users_ != null) hash ^= Users.GetHashCode();
      hash ^= joystick_.GetHashCode();
      hash ^= tactile_.GetHashCode();
      hash ^= screen_.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Time != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Time);
      }
      if (users_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Users);
      }
      joystick_.WriteTo(output, _repeated_joystick_codec);
      tactile_.WriteTo(output, _repeated_tactile_codec);
      screen_.WriteTo(output, _repeated_screen_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (Time != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Time);
      }
      if (users_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Users);
      }
      size += joystick_.CalculateSize(_repeated_joystick_codec);
      size += tactile_.CalculateSize(_repeated_tactile_codec);
      size += screen_.CalculateSize(_repeated_screen_codec);
      return size;
    }

    public void MergeFrom(Report other) {
      if (other == null) {
        return;
      }
      if (other.Time != 0) {
        Time = other.Time;
      }
      if (other.users_ != null) {
        if (users_ == null) {
          users_ = new global::Gobeam.Report.Types.Users();
        }
        Users.MergeFrom(other.Users);
      }
      joystick_.Add(other.joystick_);
      tactile_.Add(other.tactile_);
      screen_.Add(other.screen_);
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Time = input.ReadUInt32();
            break;
          }
          case 18: {
            if (users_ == null) {
              users_ = new global::Gobeam.Report.Types.Users();
            }
            input.ReadMessage(users_);
            break;
          }
          case 26: {
            joystick_.AddEntriesFrom(input, _repeated_joystick_codec);
            break;
          }
          case 34: {
            tactile_.AddEntriesFrom(input, _repeated_tactile_codec);
            break;
          }
          case 42: {
            screen_.AddEntriesFrom(input, _repeated_screen_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Report message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      /// <summary>
      ///  Contains information about the users connected to the stream.
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Users : pb::IMessage<Users> {
        private static readonly pb::MessageParser<Users> _parser = new pb::MessageParser<Users>(() => new Users());
        public static pb::MessageParser<Users> Parser { get { return _parser; } }

        public static pbr::MessageDescriptor Descriptor {
          get { return global::Gobeam.Report.Descriptor.NestedTypes[0]; }
        }

        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        public Users() {
          OnConstruction();
        }

        partial void OnConstruction();

        public Users(Users other) : this() {
          connected_ = other.connected_;
          quorum_ = other.quorum_;
          active_ = other.active_;
          qgram_ = other.qgram_.Clone();
        }

        public Users Clone() {
          return new Users(this);
        }

        /// <summary>Field number for the "connected" field.</summary>
        public const int ConnectedFieldNumber = 1;
        private uint connected_;
        /// <summary>
        ///  Total number of users connected to the stream.
        /// </summary>
        public uint Connected {
          get { return connected_; }
          set {
            connected_ = value;
          }
        }

        /// <summary>Field number for the "quorum" field.</summary>
        public const int QuorumFieldNumber = 2;
        private uint quorum_;
        /// <summary>
        ///  Number of users who gave any kind of input in the last 30 seconds.
        /// </summary>
        public uint Quorum {
          get { return quorum_; }
          set {
            quorum_ = value;
          }
        }

        /// <summary>Field number for the "active" field.</summary>
        public const int ActiveFieldNumber = 3;
        private uint active_;
        /// <summary>
        ///  Number of users who gave input in *this* report interval.
        /// </summary>
        public uint Active {
          get { return active_; }
          set {
            active_ = value;
          }
        }

        /// <summary>Field number for the "qgram" field.</summary>
        public const int QgramFieldNumber = 4;
        private static readonly pb::FieldCodec<global::Gobeam.HistogramUint1D> _repeated_qgram_codec
            = pb::FieldCodec.ForMessage(34, global::Gobeam.HistogramUint1D.Parser);
        private readonly pbc::RepeatedField<global::Gobeam.HistogramUint1D> qgram_ = new pbc::RepeatedField<global::Gobeam.HistogramUint1D>();
        /// <summary>
        ///  User activity is reported in a histographic fashion via a
        ///  1D histogram, which record the number of users who gave
        ///  any sort of input in the last (now - x) milliseconds.
        /// </summary>
        public pbc::RepeatedField<global::Gobeam.HistogramUint1D> Qgram {
          get { return qgram_; }
        }

        public override bool Equals(object other) {
          return Equals(other as Users);
        }

        public bool Equals(Users other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Connected != other.Connected) return false;
          if (Quorum != other.Quorum) return false;
          if (Active != other.Active) return false;
          if(!qgram_.Equals(other.qgram_)) return false;
          return true;
        }

        public override int GetHashCode() {
          int hash = 1;
          if (Connected != 0) hash ^= Connected.GetHashCode();
          if (Quorum != 0) hash ^= Quorum.GetHashCode();
          if (Active != 0) hash ^= Active.GetHashCode();
          hash ^= qgram_.GetHashCode();
          return hash;
        }

        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Connected != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(Connected);
          }
          if (Quorum != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(Quorum);
          }
          if (Active != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(Active);
          }
          qgram_.WriteTo(output, _repeated_qgram_codec);
        }

        public int CalculateSize() {
          int size = 0;
          if (Connected != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Connected);
          }
          if (Quorum != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Quorum);
          }
          if (Active != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Active);
          }
          size += qgram_.CalculateSize(_repeated_qgram_codec);
          return size;
        }

        public void MergeFrom(Users other) {
          if (other == null) {
            return;
          }
          if (other.Connected != 0) {
            Connected = other.Connected;
          }
          if (other.Quorum != 0) {
            Quorum = other.Quorum;
          }
          if (other.Active != 0) {
            Active = other.Active;
          }
          qgram_.Add(other.qgram_);
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Connected = input.ReadUInt32();
                break;
              }
              case 16: {
                Quorum = input.ReadUInt32();
                break;
              }
              case 24: {
                Active = input.ReadUInt32();
                break;
              }
              case 34: {
                qgram_.AddEntriesFrom(input, _repeated_qgram_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      ///  Reports for the Joystick input type.
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class JoystickInfo : pb::IMessage<JoystickInfo> {
        private static readonly pb::MessageParser<JoystickInfo> _parser = new pb::MessageParser<JoystickInfo>(() => new JoystickInfo());
        public static pb::MessageParser<JoystickInfo> Parser { get { return _parser; } }

        public static pbr::MessageDescriptor Descriptor {
          get { return global::Gobeam.Report.Descriptor.NestedTypes[1]; }
        }

        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        public JoystickInfo() {
          OnConstruction();
        }

        partial void OnConstruction();

        public JoystickInfo(JoystickInfo other) : this() {
          id_ = other.id_;
          CoordMean = other.coordMean_ != null ? other.CoordMean.Clone() : null;
          CoordStddev = other.coordStddev_ != null ? other.CoordStddev.Clone() : null;
        }

        public JoystickInfo Clone() {
          return new JoystickInfo(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private uint id_;
        /// <summary>
        ///  The id of this Joystick defined in the control editor/ Interactive Game Schema
        /// </summary>
        public uint Id {
          get { return id_; }
          set {
            id_ = value;
          }
        }

        /// <summary>Field number for the "coordMean" field.</summary>
        public const int CoordMeanFieldNumber = 2;
        private global::Gobeam.Coordinate coordMean_;
        /// <summary>
        ///  Average of all the user's positions
        /// </summary>
        public global::Gobeam.Coordinate CoordMean {
          get { return coordMean_; }
          set {
            coordMean_ = value;
          }
        }

        /// <summary>Field number for the "coordStddev" field.</summary>
        public const int CoordStddevFieldNumber = 3;
        private global::Gobeam.Coordinate coordStddev_;
        /// <summary>
        ///  Standard deviation of the above coordMean
        /// </summary>
        public global::Gobeam.Coordinate CoordStddev {
          get { return coordStddev_; }
          set {
            coordStddev_ = value;
          }
        }

        public override bool Equals(object other) {
          return Equals(other as JoystickInfo);
        }

        public bool Equals(JoystickInfo other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Id != other.Id) return false;
          if (!object.Equals(CoordMean, other.CoordMean)) return false;
          if (!object.Equals(CoordStddev, other.CoordStddev)) return false;
          return true;
        }

        public override int GetHashCode() {
          int hash = 1;
          if (Id != 0) hash ^= Id.GetHashCode();
          if (coordMean_ != null) hash ^= CoordMean.GetHashCode();
          if (coordStddev_ != null) hash ^= CoordStddev.GetHashCode();
          return hash;
        }

        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Id != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(Id);
          }
          if (coordMean_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(CoordMean);
          }
          if (coordStddev_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(CoordStddev);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (Id != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
          }
          if (coordMean_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(CoordMean);
          }
          if (coordStddev_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(CoordStddev);
          }
          return size;
        }

        public void MergeFrom(JoystickInfo other) {
          if (other == null) {
            return;
          }
          if (other.Id != 0) {
            Id = other.Id;
          }
          if (other.coordMean_ != null) {
            if (coordMean_ == null) {
              coordMean_ = new global::Gobeam.Coordinate();
            }
            CoordMean.MergeFrom(other.CoordMean);
          }
          if (other.coordStddev_ != null) {
            if (coordStddev_ == null) {
              coordStddev_ = new global::Gobeam.Coordinate();
            }
            CoordStddev.MergeFrom(other.CoordStddev);
          }
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Id = input.ReadUInt32();
                break;
              }
              case 18: {
                if (coordMean_ == null) {
                  coordMean_ = new global::Gobeam.Coordinate();
                }
                input.ReadMessage(coordMean_);
                break;
              }
              case 26: {
                if (coordStddev_ == null) {
                  coordStddev_ = new global::Gobeam.Coordinate();
                }
                input.ReadMessage(coordStddev_);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      ///  Reports for the Tactile input type.
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class TactileInfo : pb::IMessage<TactileInfo> {
        private static readonly pb::MessageParser<TactileInfo> _parser = new pb::MessageParser<TactileInfo>(() => new TactileInfo());
        public static pb::MessageParser<TactileInfo> Parser { get { return _parser; } }

        public static pbr::MessageDescriptor Descriptor {
          get { return global::Gobeam.Report.Descriptor.NestedTypes[2]; }
        }

        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        public TactileInfo() {
          OnConstruction();
        }

        partial void OnConstruction();

        public TactileInfo(TactileInfo other) : this() {
          id_ = other.id_;
          holding_ = other.holding_;
          pressFrequency_ = other.pressFrequency_;
          releaseFrequency_ = other.releaseFrequency_;
        }

        public TactileInfo Clone() {
          return new TactileInfo(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private uint id_;
        /// <summary>
        ///  The id of this Tactile defined in the control editor/ Interactive Game Schema
        /// </summary>
        public uint Id {
          get { return id_; }
          set {
            id_ = value;
          }
        }

        /// <summary>Field number for the "holding" field.</summary>
        public const int HoldingFieldNumber = 2;
        private double holding_;
        /// <summary>
        ///  Number of users holding this tactile in the report interval
        /// </summary>
        public double Holding {
          get { return holding_; }
          set {
            holding_ = value;
          }
        }

        /// <summary>Field number for the "pressFrequency" field.</summary>
        public const int PressFrequencyFieldNumber = 3;
        private double pressFrequency_;
        /// <summary>
        ///  Number of users pressing the tactile in this report interval
        /// </summary>
        public double PressFrequency {
          get { return pressFrequency_; }
          set {
            pressFrequency_ = value;
          }
        }

        /// <summary>Field number for the "releaseFrequency" field.</summary>
        public const int ReleaseFrequencyFieldNumber = 4;
        private double releaseFrequency_;
        /// <summary>
        ///  Number of users releasing the tactile in this report interval
        /// </summary>
        public double ReleaseFrequency {
          get { return releaseFrequency_; }
          set {
            releaseFrequency_ = value;
          }
        }

        public override bool Equals(object other) {
          return Equals(other as TactileInfo);
        }

        public bool Equals(TactileInfo other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Id != other.Id) return false;
          if (Holding != other.Holding) return false;
          if (PressFrequency != other.PressFrequency) return false;
          if (ReleaseFrequency != other.ReleaseFrequency) return false;
          return true;
        }

        public override int GetHashCode() {
          int hash = 1;
          if (Id != 0) hash ^= Id.GetHashCode();
          if (Holding != 0D) hash ^= Holding.GetHashCode();
          if (PressFrequency != 0D) hash ^= PressFrequency.GetHashCode();
          if (ReleaseFrequency != 0D) hash ^= ReleaseFrequency.GetHashCode();
          return hash;
        }

        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Id != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(Id);
          }
          if (Holding != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(Holding);
          }
          if (PressFrequency != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(PressFrequency);
          }
          if (ReleaseFrequency != 0D) {
            output.WriteRawTag(33);
            output.WriteDouble(ReleaseFrequency);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (Id != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
          }
          if (Holding != 0D) {
            size += 1 + 8;
          }
          if (PressFrequency != 0D) {
            size += 1 + 8;
          }
          if (ReleaseFrequency != 0D) {
            size += 1 + 8;
          }
          return size;
        }

        public void MergeFrom(TactileInfo other) {
          if (other == null) {
            return;
          }
          if (other.Id != 0) {
            Id = other.Id;
          }
          if (other.Holding != 0D) {
            Holding = other.Holding;
          }
          if (other.PressFrequency != 0D) {
            PressFrequency = other.PressFrequency;
          }
          if (other.ReleaseFrequency != 0D) {
            ReleaseFrequency = other.ReleaseFrequency;
          }
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Id = input.ReadUInt32();
                break;
              }
              case 17: {
                Holding = input.ReadDouble();
                break;
              }
              case 25: {
                PressFrequency = input.ReadDouble();
                break;
              }
              case 33: {
                ReleaseFrequency = input.ReadDouble();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      ///  Reports for the Screen input type.
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class ScreenInfo : pb::IMessage<ScreenInfo> {
        private static readonly pb::MessageParser<ScreenInfo> _parser = new pb::MessageParser<ScreenInfo>(() => new ScreenInfo());
        public static pb::MessageParser<ScreenInfo> Parser { get { return _parser; } }

        public static pbr::MessageDescriptor Descriptor {
          get { return global::Gobeam.Report.Descriptor.NestedTypes[3]; }
        }

        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        public ScreenInfo() {
          OnConstruction();
        }

        partial void OnConstruction();

        public ScreenInfo(ScreenInfo other) : this() {
          id_ = other.id_;
          clicks_ = other.clicks_;
          CoordMean = other.coordMean_ != null ? other.CoordMean.Clone() : null;
          CoordStddev = other.coordStddev_ != null ? other.CoordStddev.Clone() : null;
        }

        public ScreenInfo Clone() {
          return new ScreenInfo(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private uint id_;
        /// <summary>
        ///  The id of this Screen defined in the control editor/ Interactive Game Schema
        /// </summary>
        public uint Id {
          get { return id_; }
          set {
            id_ = value;
          }
        }

        /// <summary>Field number for the "clicks" field.</summary>
        public const int ClicksFieldNumber = 2;
        private double clicks_;
        /// <summary>
        ///  The number of clicks users made this analysis cycle.
        /// </summary>
        public double Clicks {
          get { return clicks_; }
          set {
            clicks_ = value;
          }
        }

        /// <summary>Field number for the "coordMean" field.</summary>
        public const int CoordMeanFieldNumber = 3;
        private global::Gobeam.Coordinate coordMean_;
        /// <summary>
        ///  Average of all the user's positions
        /// </summary>
        public global::Gobeam.Coordinate CoordMean {
          get { return coordMean_; }
          set {
            coordMean_ = value;
          }
        }

        /// <summary>Field number for the "coordStddev" field.</summary>
        public const int CoordStddevFieldNumber = 4;
        private global::Gobeam.Coordinate coordStddev_;
        /// <summary>
        ///  Standard deviation of the above coordMean
        /// </summary>
        public global::Gobeam.Coordinate CoordStddev {
          get { return coordStddev_; }
          set {
            coordStddev_ = value;
          }
        }

        public override bool Equals(object other) {
          return Equals(other as ScreenInfo);
        }

        public bool Equals(ScreenInfo other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Id != other.Id) return false;
          if (Clicks != other.Clicks) return false;
          if (!object.Equals(CoordMean, other.CoordMean)) return false;
          if (!object.Equals(CoordStddev, other.CoordStddev)) return false;
          return true;
        }

        public override int GetHashCode() {
          int hash = 1;
          if (Id != 0) hash ^= Id.GetHashCode();
          if (Clicks != 0D) hash ^= Clicks.GetHashCode();
          if (coordMean_ != null) hash ^= CoordMean.GetHashCode();
          if (coordStddev_ != null) hash ^= CoordStddev.GetHashCode();
          return hash;
        }

        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Id != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(Id);
          }
          if (Clicks != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(Clicks);
          }
          if (coordMean_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(CoordMean);
          }
          if (coordStddev_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(CoordStddev);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (Id != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
          }
          if (Clicks != 0D) {
            size += 1 + 8;
          }
          if (coordMean_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(CoordMean);
          }
          if (coordStddev_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(CoordStddev);
          }
          return size;
        }

        public void MergeFrom(ScreenInfo other) {
          if (other == null) {
            return;
          }
          if (other.Id != 0) {
            Id = other.Id;
          }
          if (other.Clicks != 0D) {
            Clicks = other.Clicks;
          }
          if (other.coordMean_ != null) {
            if (coordMean_ == null) {
              coordMean_ = new global::Gobeam.Coordinate();
            }
            CoordMean.MergeFrom(other.CoordMean);
          }
          if (other.coordStddev_ != null) {
            if (coordStddev_ == null) {
              coordStddev_ = new global::Gobeam.Coordinate();
            }
            CoordStddev.MergeFrom(other.CoordStddev);
          }
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Id = input.ReadUInt32();
                break;
              }
              case 17: {
                Clicks = input.ReadDouble();
                break;
              }
              case 26: {
                if (coordMean_ == null) {
                  coordMean_ = new global::Gobeam.Coordinate();
                }
                input.ReadMessage(coordMean_);
                break;
              }
              case 34: {
                if (coordStddev_ == null) {
                  coordStddev_ = new global::Gobeam.Coordinate();
                }
                input.ReadMessage(coordStddev_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///  An error in response to some invalid input or event.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Error : pb::IMessage<Error> {
    private static readonly pb::MessageParser<Error> _parser = new pb::MessageParser<Error>(() => new Error());
    public static pb::MessageParser<Error> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Gobeam.BeamReflection.Descriptor.MessageTypes[3]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public Error() {
      OnConstruction();
    }

    partial void OnConstruction();

    public Error(Error other) : this() {
      message_ = other.message_;
    }

    public Error Clone() {
      return new Error(this);
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 1;
    private string message_ = "";
    /// <summary>
    ///  An error message
    /// </summary>
    public string Message {
      get { return message_; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    public override bool Equals(object other) {
      return Equals(other as Error);
    }

    public bool Equals(Error other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Message != other.Message) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Message.Length != 0) hash ^= Message.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Message.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Message);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Message.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      return size;
    }

    public void MergeFrom(Error other) {
      if (other == null) {
        return;
      }
      if (other.Message.Length != 0) {
        Message = other.Message;
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Message = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  A ProgressUpdate message may be sent up periodically from
  ///  the Robot. It contains an array of objects to update the
  ///  multiple controls on the frontend.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class ProgressUpdate : pb::IMessage<ProgressUpdate> {
    private static readonly pb::MessageParser<ProgressUpdate> _parser = new pb::MessageParser<ProgressUpdate>(() => new ProgressUpdate());
    public static pb::MessageParser<ProgressUpdate> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Gobeam.BeamReflection.Descriptor.MessageTypes[4]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public ProgressUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    public ProgressUpdate(ProgressUpdate other) : this() {
      state_ = other.state_;
      joystick_ = other.joystick_.Clone();
      tactile_ = other.tactile_.Clone();
      screen_ = other.screen_.Clone();
    }

    public ProgressUpdate Clone() {
      return new ProgressUpdate(this);
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 3;
    private string state_ = "";
    /// <summary>
    ///  State to change to. States with the given state in their `states` array
    ///  will be visible. If not passed, the state will not be changed.
    ///  The default state at initialization of the robot is simply "default".
    /// </summary>
    public string State {
      get { return state_; }
      set {
        state_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "joystick" field.</summary>
    public const int JoystickFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Gobeam.ProgressUpdate.Types.JoystickUpdate> _repeated_joystick_codec
        = pb::FieldCodec.ForMessage(10, global::Gobeam.ProgressUpdate.Types.JoystickUpdate.Parser);
    private readonly pbc::RepeatedField<global::Gobeam.ProgressUpdate.Types.JoystickUpdate> joystick_ = new pbc::RepeatedField<global::Gobeam.ProgressUpdate.Types.JoystickUpdate>();
    public pbc::RepeatedField<global::Gobeam.ProgressUpdate.Types.JoystickUpdate> Joystick {
      get { return joystick_; }
    }

    /// <summary>Field number for the "tactile" field.</summary>
    public const int TactileFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Gobeam.ProgressUpdate.Types.TactileUpdate> _repeated_tactile_codec
        = pb::FieldCodec.ForMessage(18, global::Gobeam.ProgressUpdate.Types.TactileUpdate.Parser);
    private readonly pbc::RepeatedField<global::Gobeam.ProgressUpdate.Types.TactileUpdate> tactile_ = new pbc::RepeatedField<global::Gobeam.ProgressUpdate.Types.TactileUpdate>();
    public pbc::RepeatedField<global::Gobeam.ProgressUpdate.Types.TactileUpdate> Tactile {
      get { return tactile_; }
    }

    /// <summary>Field number for the "screen" field.</summary>
    public const int ScreenFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Gobeam.ProgressUpdate.Types.ScreenUpdate> _repeated_screen_codec
        = pb::FieldCodec.ForMessage(34, global::Gobeam.ProgressUpdate.Types.ScreenUpdate.Parser);
    private readonly pbc::RepeatedField<global::Gobeam.ProgressUpdate.Types.ScreenUpdate> screen_ = new pbc::RepeatedField<global::Gobeam.ProgressUpdate.Types.ScreenUpdate>();
    public pbc::RepeatedField<global::Gobeam.ProgressUpdate.Types.ScreenUpdate> Screen {
      get { return screen_; }
    }

    public override bool Equals(object other) {
      return Equals(other as ProgressUpdate);
    }

    public bool Equals(ProgressUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (State != other.State) return false;
      if(!joystick_.Equals(other.joystick_)) return false;
      if(!tactile_.Equals(other.tactile_)) return false;
      if(!screen_.Equals(other.screen_)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (State.Length != 0) hash ^= State.GetHashCode();
      hash ^= joystick_.GetHashCode();
      hash ^= tactile_.GetHashCode();
      hash ^= screen_.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      joystick_.WriteTo(output, _repeated_joystick_codec);
      tactile_.WriteTo(output, _repeated_tactile_codec);
      if (State.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(State);
      }
      screen_.WriteTo(output, _repeated_screen_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (State.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(State);
      }
      size += joystick_.CalculateSize(_repeated_joystick_codec);
      size += tactile_.CalculateSize(_repeated_tactile_codec);
      size += screen_.CalculateSize(_repeated_screen_codec);
      return size;
    }

    public void MergeFrom(ProgressUpdate other) {
      if (other == null) {
        return;
      }
      if (other.State.Length != 0) {
        State = other.State;
      }
      joystick_.Add(other.joystick_);
      tactile_.Add(other.tactile_);
      screen_.Add(other.screen_);
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            joystick_.AddEntriesFrom(input, _repeated_joystick_codec);
            break;
          }
          case 18: {
            tactile_.AddEntriesFrom(input, _repeated_tactile_codec);
            break;
          }
          case 26: {
            State = input.ReadString();
            break;
          }
          case 34: {
            screen_.AddEntriesFrom(input, _repeated_screen_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ProgressUpdate message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class JoystickUpdate : pb::IMessage<JoystickUpdate> {
        private static readonly pb::MessageParser<JoystickUpdate> _parser = new pb::MessageParser<JoystickUpdate>(() => new JoystickUpdate());
        public static pb::MessageParser<JoystickUpdate> Parser { get { return _parser; } }

        public static pbr::MessageDescriptor Descriptor {
          get { return global::Gobeam.ProgressUpdate.Descriptor.NestedTypes[0]; }
        }

        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        public JoystickUpdate() {
          OnConstruction();
        }

        partial void OnConstruction();

        public JoystickUpdate(JoystickUpdate other) : this() {
          id_ = other.id_;
          angle_ = other.angle_;
          intensity_ = other.intensity_;
          disabled_ = other.disabled_;
        }

        public JoystickUpdate Clone() {
          return new JoystickUpdate(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private uint id_;
        /// <summary>
        ///  The ID of the joystick control to update
        /// </summary>
        public uint Id {
          get { return id_; }
          set {
            id_ = value;
          }
        }

        /// <summary>Field number for the "angle" field.</summary>
        public const int AngleFieldNumber = 2;
        private double angle_;
        /// <summary>
        ///  The angle to move the "pointer" that appears around the joystick
        ///  to. This is usually used to indicate the average direction that
        ///  users pointing to. This is given in radians, in the range
        ///  [0, 2π), with the same alignment as the standard unit circle.
        /// </summary>
        public double Angle {
          get { return angle_; }
          set {
            angle_ = value;
          }
        }

        /// <summary>Field number for the "intensity" field.</summary>
        public const int IntensityFieldNumber = 3;
        private double intensity_;
        /// <summary>
        ///  Intensity the pointer should appear at. This is often used to
        ///  indicate how strongly users are moving in a direction.
        ///  Should be given in the range [0, 1].
        /// </summary>
        public double Intensity {
          get { return intensity_; }
          set {
            intensity_ = value;
          }
        }

        /// <summary>Field number for the "disabled" field.</summary>
        public const int DisabledFieldNumber = 4;
        private bool disabled_;
        /// <summary>
        ///  Changes the disabled or enabled state of the control. If you pass
        ///  `disabled = true` in a progress update, users won't be able to
        ///  give input on that control until you send `disabled = false`.
        /// </summary>
        public bool Disabled {
          get { return disabled_; }
          set {
            disabled_ = value;
          }
        }

        public override bool Equals(object other) {
          return Equals(other as JoystickUpdate);
        }

        public bool Equals(JoystickUpdate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Id != other.Id) return false;
          if (Angle != other.Angle) return false;
          if (Intensity != other.Intensity) return false;
          if (Disabled != other.Disabled) return false;
          return true;
        }

        public override int GetHashCode() {
          int hash = 1;
          if (Id != 0) hash ^= Id.GetHashCode();
          if (Angle != 0D) hash ^= Angle.GetHashCode();
          if (Intensity != 0D) hash ^= Intensity.GetHashCode();
          if (Disabled != false) hash ^= Disabled.GetHashCode();
          return hash;
        }

        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Id != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(Id);
          }
          if (Angle != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(Angle);
          }
          if (Intensity != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(Intensity);
          }
          if (Disabled != false) {
            output.WriteRawTag(32);
            output.WriteBool(Disabled);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (Id != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
          }
          if (Angle != 0D) {
            size += 1 + 8;
          }
          if (Intensity != 0D) {
            size += 1 + 8;
          }
          if (Disabled != false) {
            size += 1 + 1;
          }
          return size;
        }

        public void MergeFrom(JoystickUpdate other) {
          if (other == null) {
            return;
          }
          if (other.Id != 0) {
            Id = other.Id;
          }
          if (other.Angle != 0D) {
            Angle = other.Angle;
          }
          if (other.Intensity != 0D) {
            Intensity = other.Intensity;
          }
          if (other.Disabled != false) {
            Disabled = other.Disabled;
          }
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Id = input.ReadUInt32();
                break;
              }
              case 17: {
                Angle = input.ReadDouble();
                break;
              }
              case 25: {
                Intensity = input.ReadDouble();
                break;
              }
              case 32: {
                Disabled = input.ReadBool();
                break;
              }
            }
          }
        }

      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class TactileUpdate : pb::IMessage<TactileUpdate> {
        private static readonly pb::MessageParser<TactileUpdate> _parser = new pb::MessageParser<TactileUpdate>(() => new TactileUpdate());
        public static pb::MessageParser<TactileUpdate> Parser { get { return _parser; } }

        public static pbr::MessageDescriptor Descriptor {
          get { return global::Gobeam.ProgressUpdate.Descriptor.NestedTypes[1]; }
        }

        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        public TactileUpdate() {
          OnConstruction();
        }

        partial void OnConstruction();

        public TactileUpdate(TactileUpdate other) : this() {
          id_ = other.id_;
          cooldown_ = other.cooldown_;
          fired_ = other.fired_;
          progress_ = other.progress_;
          disabled_ = other.disabled_;
        }

        public TactileUpdate Clone() {
          return new TactileUpdate(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private uint id_;
        /// <summary>
        ///  The ID of the tactile control to update
        /// </summary>
        public uint Id {
          get { return id_; }
          set {
            id_ = value;
          }
        }

        /// <summary>Field number for the "cooldown" field.</summary>
        public const int CooldownFieldNumber = 2;
        private uint cooldown_;
        /// <summary>
        ///  Starts a cooldown for all users, with a duration given in milliseconds.
        ///  Users will not be able to press the button until the cooldown is
        ///  over. Users who currently are pressing the button will be marked
        ///  as having released it. Sending another cooldown before the first
        ///  is over sets the cooldown's duration. The cooldown duration will
        ///  decrement automatically.
        /// </summary>
        public uint Cooldown {
          get { return cooldown_; }
          set {
            cooldown_ = value;
          }
        }

        /// <summary>Field number for the "fired" field.</summary>
        public const int FiredFieldNumber = 3;
        private bool fired_;
        /// <summary>
        ///  Marks the button has having been fired, showing a "pulse"
        ///  on the Beam frontend.
        /// </summary>
        public bool Fired {
          get { return fired_; }
          set {
            fired_ = value;
          }
        }

        /// <summary>Field number for the "progress" field.</summary>
        public const int ProgressFieldNumber = 4;
        private double progress_;
        /// <summary>
        ///  Sets the progress of the button toward some threshold, appearing
        ///  as a sort of progress bar on the frontend. Should be given in the
        ///  range [0, 1].
        /// </summary>
        public double Progress {
          get { return progress_; }
          set {
            progress_ = value;
          }
        }

        /// <summary>Field number for the "disabled" field.</summary>
        public const int DisabledFieldNumber = 5;
        private bool disabled_;
        /// <summary>
        ///  Changes the disabled or enabled state of the control. If you pass
        ///  `disabled = true` in a progress update, users won't be able to
        ///  give input on that control until you send `disabled = false`.
        /// </summary>
        public bool Disabled {
          get { return disabled_; }
          set {
            disabled_ = value;
          }
        }

        public override bool Equals(object other) {
          return Equals(other as TactileUpdate);
        }

        public bool Equals(TactileUpdate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Id != other.Id) return false;
          if (Cooldown != other.Cooldown) return false;
          if (Fired != other.Fired) return false;
          if (Progress != other.Progress) return false;
          if (Disabled != other.Disabled) return false;
          return true;
        }

        public override int GetHashCode() {
          int hash = 1;
          if (Id != 0) hash ^= Id.GetHashCode();
          if (Cooldown != 0) hash ^= Cooldown.GetHashCode();
          if (Fired != false) hash ^= Fired.GetHashCode();
          if (Progress != 0D) hash ^= Progress.GetHashCode();
          if (Disabled != false) hash ^= Disabled.GetHashCode();
          return hash;
        }

        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Id != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(Id);
          }
          if (Cooldown != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(Cooldown);
          }
          if (Fired != false) {
            output.WriteRawTag(24);
            output.WriteBool(Fired);
          }
          if (Progress != 0D) {
            output.WriteRawTag(33);
            output.WriteDouble(Progress);
          }
          if (Disabled != false) {
            output.WriteRawTag(40);
            output.WriteBool(Disabled);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (Id != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
          }
          if (Cooldown != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Cooldown);
          }
          if (Fired != false) {
            size += 1 + 1;
          }
          if (Progress != 0D) {
            size += 1 + 8;
          }
          if (Disabled != false) {
            size += 1 + 1;
          }
          return size;
        }

        public void MergeFrom(TactileUpdate other) {
          if (other == null) {
            return;
          }
          if (other.Id != 0) {
            Id = other.Id;
          }
          if (other.Cooldown != 0) {
            Cooldown = other.Cooldown;
          }
          if (other.Fired != false) {
            Fired = other.Fired;
          }
          if (other.Progress != 0D) {
            Progress = other.Progress;
          }
          if (other.Disabled != false) {
            Disabled = other.Disabled;
          }
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Id = input.ReadUInt32();
                break;
              }
              case 16: {
                Cooldown = input.ReadUInt32();
                break;
              }
              case 24: {
                Fired = input.ReadBool();
                break;
              }
              case 33: {
                Progress = input.ReadDouble();
                break;
              }
              case 40: {
                Disabled = input.ReadBool();
                break;
              }
            }
          }
        }

      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class ScreenUpdate : pb::IMessage<ScreenUpdate> {
        private static readonly pb::MessageParser<ScreenUpdate> _parser = new pb::MessageParser<ScreenUpdate>(() => new ScreenUpdate());
        public static pb::MessageParser<ScreenUpdate> Parser { get { return _parser; } }

        public static pbr::MessageDescriptor Descriptor {
          get { return global::Gobeam.ProgressUpdate.Descriptor.NestedTypes[2]; }
        }

        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        public ScreenUpdate() {
          OnConstruction();
        }

        partial void OnConstruction();

        public ScreenUpdate(ScreenUpdate other) : this() {
          id_ = other.id_;
          clicks_ = other.clicks_.Clone();
          disabled_ = other.disabled_;
        }

        public ScreenUpdate Clone() {
          return new ScreenUpdate(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private uint id_;
        /// <summary>
        ///  The ID of the screen control to update
        /// </summary>
        public uint Id {
          get { return id_; }
          set {
            id_ = value;
          }
        }

        /// <summary>Field number for the "clicks" field.</summary>
        public const int ClicksFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Gobeam.ProgressUpdate.Types.ScreenUpdate.Types.Click> _repeated_clicks_codec
            = pb::FieldCodec.ForMessage(18, global::Gobeam.ProgressUpdate.Types.ScreenUpdate.Types.Click.Parser);
        private readonly pbc::RepeatedField<global::Gobeam.ProgressUpdate.Types.ScreenUpdate.Types.Click> clicks_ = new pbc::RepeatedField<global::Gobeam.ProgressUpdate.Types.ScreenUpdate.Types.Click>();
        /// <summary>
        ///  A list of clicks that will be displayed on the frontend as pulses
        ///  on the screen. You can show multiple pulses per cycle.
        /// </summary>
        public pbc::RepeatedField<global::Gobeam.ProgressUpdate.Types.ScreenUpdate.Types.Click> Clicks {
          get { return clicks_; }
        }

        /// <summary>Field number for the "disabled" field.</summary>
        public const int DisabledFieldNumber = 3;
        private bool disabled_;
        /// <summary>
        ///  Changes the disabled or enabled state of the control. If you pass
        ///  `disabled = true` in a progress update, users won't be able to
        ///  give input on that control until you send `disabled = false`.
        /// </summary>
        public bool Disabled {
          get { return disabled_; }
          set {
            disabled_ = value;
          }
        }

        public override bool Equals(object other) {
          return Equals(other as ScreenUpdate);
        }

        public bool Equals(ScreenUpdate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Id != other.Id) return false;
          if(!clicks_.Equals(other.clicks_)) return false;
          if (Disabled != other.Disabled) return false;
          return true;
        }

        public override int GetHashCode() {
          int hash = 1;
          if (Id != 0) hash ^= Id.GetHashCode();
          hash ^= clicks_.GetHashCode();
          if (Disabled != false) hash ^= Disabled.GetHashCode();
          return hash;
        }

        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Id != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(Id);
          }
          clicks_.WriteTo(output, _repeated_clicks_codec);
          if (Disabled != false) {
            output.WriteRawTag(24);
            output.WriteBool(Disabled);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (Id != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
          }
          size += clicks_.CalculateSize(_repeated_clicks_codec);
          if (Disabled != false) {
            size += 1 + 1;
          }
          return size;
        }

        public void MergeFrom(ScreenUpdate other) {
          if (other == null) {
            return;
          }
          if (other.Id != 0) {
            Id = other.Id;
          }
          clicks_.Add(other.clicks_);
          if (other.Disabled != false) {
            Disabled = other.Disabled;
          }
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Id = input.ReadUInt32();
                break;
              }
              case 18: {
                clicks_.AddEntriesFrom(input, _repeated_clicks_codec);
                break;
              }
              case 24: {
                Disabled = input.ReadBool();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the ScreenUpdate message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static partial class Types {
          [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
          public sealed partial class Click : pb::IMessage<Click> {
            private static readonly pb::MessageParser<Click> _parser = new pb::MessageParser<Click>(() => new Click());
            public static pb::MessageParser<Click> Parser { get { return _parser; } }

            public static pbr::MessageDescriptor Descriptor {
              get { return global::Gobeam.ProgressUpdate.Types.ScreenUpdate.Descriptor.NestedTypes[0]; }
            }

            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            public Click() {
              OnConstruction();
            }

            partial void OnConstruction();

            public Click(Click other) : this() {
              Coordinate = other.coordinate_ != null ? other.Coordinate.Clone() : null;
              intensity_ = other.intensity_;
            }

            public Click Clone() {
              return new Click(this);
            }

            /// <summary>Field number for the "coordinate" field.</summary>
            public const int CoordinateFieldNumber = 1;
            private global::Gobeam.Coordinate coordinate_;
            /// <summary>
            ///  x and y follow the same coordinate system as described in
            ///  Report.ScreenInfo .
            /// </summary>
            public global::Gobeam.Coordinate Coordinate {
              get { return coordinate_; }
              set {
                coordinate_ = value;
              }
            }

            /// <summary>Field number for the "intensity" field.</summary>
            public const int IntensityFieldNumber = 2;
            private double intensity_;
            /// <summary>
            ///  Intensity of the pulse from 0 to 1.
            /// </summary>
            public double Intensity {
              get { return intensity_; }
              set {
                intensity_ = value;
              }
            }

            public override bool Equals(object other) {
              return Equals(other as Click);
            }

            public bool Equals(Click other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(Coordinate, other.Coordinate)) return false;
              if (Intensity != other.Intensity) return false;
              return true;
            }

            public override int GetHashCode() {
              int hash = 1;
              if (coordinate_ != null) hash ^= Coordinate.GetHashCode();
              if (Intensity != 0D) hash ^= Intensity.GetHashCode();
              return hash;
            }

            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            public void WriteTo(pb::CodedOutputStream output) {
              if (coordinate_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(Coordinate);
              }
              if (Intensity != 0D) {
                output.WriteRawTag(17);
                output.WriteDouble(Intensity);
              }
            }

            public int CalculateSize() {
              int size = 0;
              if (coordinate_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Coordinate);
              }
              if (Intensity != 0D) {
                size += 1 + 8;
              }
              return size;
            }

            public void MergeFrom(Click other) {
              if (other == null) {
                return;
              }
              if (other.coordinate_ != null) {
                if (coordinate_ == null) {
                  coordinate_ = new global::Gobeam.Coordinate();
                }
                Coordinate.MergeFrom(other.Coordinate);
              }
              if (other.Intensity != 0D) {
                Intensity = other.Intensity;
              }
            }

            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 10: {
                    if (coordinate_ == null) {
                      coordinate_ = new global::Gobeam.Coordinate();
                    }
                    input.ReadMessage(coordinate_);
                    break;
                  }
                  case 17: {
                    Intensity = input.ReadDouble();
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  ///  HistogramUint1D is a point on a 1-dimensional histogram, where `x` is the
  ///  defined horizontal axis and y is the vertical axis.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class HistogramUint1D : pb::IMessage<HistogramUint1D> {
    private static readonly pb::MessageParser<HistogramUint1D> _parser = new pb::MessageParser<HistogramUint1D>(() => new HistogramUint1D());
    public static pb::MessageParser<HistogramUint1D> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Gobeam.BeamReflection.Descriptor.MessageTypes[5]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public HistogramUint1D() {
      OnConstruction();
    }

    partial void OnConstruction();

    public HistogramUint1D(HistogramUint1D other) : this() {
      x_ = other.x_;
      y_ = other.y_;
    }

    public HistogramUint1D Clone() {
      return new HistogramUint1D(this);
    }

    /// <summary>Field number for the "x" field.</summary>
    public const int XFieldNumber = 1;
    private uint x_;
    public uint X {
      get { return x_; }
      set {
        x_ = value;
      }
    }

    /// <summary>Field number for the "y" field.</summary>
    public const int YFieldNumber = 2;
    private uint y_;
    public uint Y {
      get { return y_; }
      set {
        y_ = value;
      }
    }

    public override bool Equals(object other) {
      return Equals(other as HistogramUint1D);
    }

    public bool Equals(HistogramUint1D other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (X != other.X) return false;
      if (Y != other.Y) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (X != 0) hash ^= X.GetHashCode();
      if (Y != 0) hash ^= Y.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (X != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(X);
      }
      if (Y != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Y);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (X != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(X);
      }
      if (Y != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Y);
      }
      return size;
    }

    public void MergeFrom(HistogramUint1D other) {
      if (other == null) {
        return;
      }
      if (other.X != 0) {
        X = other.X;
      }
      if (other.Y != 0) {
        Y = other.Y;
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            X = input.ReadUInt32();
            break;
          }
          case 16: {
            Y = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Coordinate represents a single x/y point on a screen or joystick.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Coordinate : pb::IMessage<Coordinate> {
    private static readonly pb::MessageParser<Coordinate> _parser = new pb::MessageParser<Coordinate>(() => new Coordinate());
    public static pb::MessageParser<Coordinate> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Gobeam.BeamReflection.Descriptor.MessageTypes[6]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public Coordinate() {
      OnConstruction();
    }

    partial void OnConstruction();

    public Coordinate(Coordinate other) : this() {
      x_ = other.x_;
      y_ = other.y_;
    }

    public Coordinate Clone() {
      return new Coordinate(this);
    }

    /// <summary>Field number for the "x" field.</summary>
    public const int XFieldNumber = 1;
    private double x_;
    public double X {
      get { return x_; }
      set {
        x_ = value;
      }
    }

    /// <summary>Field number for the "y" field.</summary>
    public const int YFieldNumber = 2;
    private double y_;
    public double Y {
      get { return y_; }
      set {
        y_ = value;
      }
    }

    public override bool Equals(object other) {
      return Equals(other as Coordinate);
    }

    public bool Equals(Coordinate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (X != other.X) return false;
      if (Y != other.Y) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (X != 0D) hash ^= X.GetHashCode();
      if (Y != 0D) hash ^= Y.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (X != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(X);
      }
      if (Y != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(Y);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (X != 0D) {
        size += 1 + 8;
      }
      if (Y != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    public void MergeFrom(Coordinate other) {
      if (other == null) {
        return;
      }
      if (other.X != 0D) {
        X = other.X;
      }
      if (other.Y != 0D) {
        Y = other.Y;
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            X = input.ReadDouble();
            break;
          }
          case 17: {
            Y = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
